#include <SPI.h>
#include <Ethernet.h>
#include <HttpClient.h>
#include <Cosm.h>
#include <OneWire.h>

#include "cosm.key"

// MAC address for your Ethernet shield
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// Your Cosm key to let you upload data
char cosmKey[] = PRIVATE_COSM_KEY;  // defined in cosm.key

// Analog pin which we're monitoring (0 and 1 are used by the Ethernet shield)
int sensorPin = 2;

// Define the strings for our datastream IDs
char indoorSensorId[] = "indoor";
char outdoorSensorId[] = "outdoor";

CosmDatastream datastreams[] = {
  CosmDatastream(indoorSensorId, strlen(indoorSensorId), DATASTREAM_FLOAT),
  CosmDatastream(outdoorSensorId, strlen(outdoorSensorId), DATASTREAM_FLOAT),
};
// Finally, wrap the datastreams into a feed
CosmFeed feed(102125, datastreams, 2 /* number of datastreams */);

EthernetClient client;
CosmClient cosmclient(client);

// ----------------------------------------------------------------------------

OneWire ds(20);		// on pin 2
int sensor_num;

void test_sensors(void)
{
	byte addr[8];
	byte type_s = 0;
	float celsius, fahrenheit;
	byte present = 0;
	byte data[12];

	if (!ds.search(addr))
	{
		Serial.println("No more addresses.");
		Serial.println();
		ds.reset_search();
		delay(3000);
		sensor_num = 0;
		return;
	}

//	Serial.print("ROM =");
//	for(byte i = 0; i < 8; i++)
//	{
//		Serial.write(' ');
//		Serial.print(addr[i], HEX);
//	}

	if (OneWire::crc8(addr, 7) != addr[7])
	{
		Serial.println("CRC is not valid!");
		return;
	}
	Serial.println();

//	// the first ROM byte indicates which chip
//	switch (addr[0])
//	{
//	case 0x10:
//		Serial.println("  Chip = DS18S20");  // or old DS1820
//		type_s = 1;
//		break;
//	case 0x28:
//		Serial.println("  Chip = DS18B20");
//		type_s = 0;
//		break;
//	case 0x22:
//		Serial.println("  Chip = DS1822");
//		type_s = 0;
//		break;
//	default:
//		Serial.println("Device is not a DS18x20 family device.");
//		return;
//	}

	ds.reset();
	ds.select(addr);
	ds.write(0x44);         // start conversion

	delay(1000);     // maybe 750ms is enough, maybe not
	// we might do a ds.depower() here, but the reset will take care of it.

	present = ds.reset();
	ds.select(addr);
	ds.write(0xBE);         // Read Scratchpad

//	Serial.print("  Data = ");
//	Serial.print(present, HEX);
//	Serial.print(" ");
	for (byte i = 0; i < 9; i++)
	{           // we need 9 bytes
		data[i] = ds.read();
//		Serial.print(data[i], HEX);
//		Serial.print(" ");
	}
//	Serial.print(" CRC=");
//	Serial.print(OneWire::crc8(data, 8), HEX);
//	Serial.println();

	// convert the data to actual temperature

	unsigned int raw = (data[1] << 8) | data[0];
	if (type_s)
	{
		raw = raw << 3; // 9 bit resolution default
		if (data[7] == 0x10) {
			// count remain gives full 12 bit resolution
			raw = (raw & 0xFFF0) + 12 - data[6];
		}
	}
	else
	{
		byte cfg = (data[4] & 0x60);
		if (cfg == 0x00)
			raw = raw << 3;  // 9 bit resolution, 93.75 ms
		else if (cfg == 0x20)
			raw = raw << 2; // 10 bit res, 187.5 ms
		else if (cfg == 0x40)
			raw = raw << 1; // 11 bit res, 375 ms
		// default is 12 bit resolution, 750 ms conversion time
	}
	celsius = (float) raw / 16.0;
	fahrenheit = celsius * 1.8 + 32.0;
	Serial.print("Sensor: ");
	Serial.print(sensor_num);

	Serial.print("  Temperature = ");
	Serial.print(celsius);
	Serial.print(" Celsius, ");

	sensor_num++;
}

void setup()
{
  // put your setup code here, to run once:
  Serial.begin(9600);

  Serial.println("Starting multiple datastream upload to Cosm...");
  Serial.println();

  while (Ethernet.begin(mac) != 1)
  {
    Serial.println("Error getting IP address via DHCP, trying again...");
    delay(15000);
  }

  sensor_num = 0;
}

void loop()
{

//  datastreams[0].setFloat(22.3);
//
//  Serial.print("Read indoor sensor value ");
//  Serial.println(datastreams[0].getFloat());
//
//  datastreams[1].setFloat(4.5);
//  Serial.print("Read outdoor sensor value ");
//  Serial.println(datastreams[1].getFloat());
//
//  Serial.println("Uploading it to Cosm");
//  int ret = cosmclient.put(feed, cosmKey);
//  Serial.print("cosmclient.put returned ");
//  Serial.println(ret);
//
//  Serial.println();

	test_sensors();

	//delay(15000);
}

